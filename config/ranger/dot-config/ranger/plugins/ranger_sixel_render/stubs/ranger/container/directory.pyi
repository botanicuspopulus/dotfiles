from _typeshed import Incomplete
from collections.abc import Generator
from ranger.container.file import File as File
from ranger.container.fsobject import BAD_INFO as BAD_INFO, FileSystemObject as FileSystemObject
from ranger.container.settings import LocalSettings as LocalSettings
from ranger.core.loader import Loadable as Loadable
from ranger.ext.accumulator import Accumulator as Accumulator
from ranger.ext.human_readable import human_readable as human_readable
from ranger.ext.lazy_property import lazy_property as lazy_property
from ranger.ext.mount_path import mount_path as mount_path
from ranger.ext.vcs import Vcs as Vcs

def sort_by_basename(path): ...
def sort_by_basename_icase(path): ...
def sort_by_directory(path): ...
def sort_naturally(path): ...
def sort_naturally_icase(path): ...
def sort_unicode_wrapper_string(old_sort_func): ...
def sort_unicode_wrapper_list(old_sort_func): ...
def accept_file(fobj, filters): ...
def walklevel(some_dir, level) -> Generator[Incomplete]: ...
def mtimelevel(path, level): ...

class InodeFilterConstants:
    DIRS: str
    FILES: str
    LINKS: str

class Directory(FileSystemObject, Accumulator, Loadable):
    is_directory: bool
    enterable: bool
    load_generator: Incomplete
    cycle_list: Incomplete
    loading: bool
    progressbar_supported: bool
    flat: int
    filenames: Incomplete
    files: Incomplete
    files_all: Incomplete
    filter: Incomplete
    temporary_filter: Incomplete
    narrow_filter: Incomplete
    inode_type_filter: Incomplete
    marked_items: Incomplete
    scroll_begin: int
    mount_path: str
    disk_usage: int
    last_update_time: int
    load_content_mtime: int
    order_outdated: bool
    content_outdated: bool
    content_loaded: bool
    has_vcschild: bool
    cumulative_size_calculated: bool
    sort_dict: Incomplete
    filter_stack: Incomplete
    settings: Incomplete
    def __init__(self, path, **kw) -> None: ...
    def vcs(self): ...
    def signal_function_factory(self, function): ...
    def request_resort(self) -> None: ...
    def request_reload(self) -> None: ...
    def get_list(self): ...
    def mark_item(self, item, val) -> None: ...
    def toggle_mark(self, item) -> None: ...
    def toggle_all_marks(self) -> None: ...
    def mark_all(self, val) -> None: ...
    def get_selection(self): ...
    pointed_obj: Incomplete
    def refilter(self): ...
    percent: int
    def load_bit_by_bit(self) -> Generator[None]: ...
    def unload(self) -> None: ...
    def load_content(self, schedule: Incomplete | None = None) -> None: ...
    def sort(self) -> None: ...
    def look_up_cumulative_size(self) -> None: ...
    accessible: bool
    def size(self): ...
    def infostring(self): ...
    def runnable(self): ...
    def sort_if_outdated(self): ...
    def move_to_obj(self, arg, attr: Incomplete | None = None) -> None: ...
    pointer: Incomplete
    def search_fnc(self, fnc, offset: int = 1, forward: bool = True): ...
    def set_cycle_list(self, lst) -> None: ...
    def cycle(self, forward: bool = True) -> None: ...
    def correct_pointer(self) -> None: ...
    def load_content_once(self, *a, **k): ...
    def load_content_if_outdated(self, *a, **k): ...
    def get_description(self): ...
    last_used: Incomplete
    def use(self) -> None: ...
    def is_older_than(self, seconds): ...
    def go(self, history: bool = True): ...
    def empty(self): ...
    def set_linemode_of_children(self, mode) -> None: ...
    def __nonzero__(self): ...
    __bool__ = __nonzero__
    def __len__(self) -> int: ...
    def __eq__(self, other): ...
    def __neq__(self, other): ...
    def __hash__(self): ...
